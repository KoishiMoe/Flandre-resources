# Flandre对话词库格式

版本：v1

由于Flandre的对话系统比较复杂 ~~（饼画的比较大）~~ ，因此相较于同类项目，词库的结构更复杂，存储的附加信息量也更多。

为了保证后续开发的连续性，以及让用户可以自定义词库，在此处提供词库json文件的规范格式，以供参考。如有错漏或需要补充之处，还请提交issue。

挖个坑，后续为了方便编辑，我大概会写一个简单的程序，用来快速实现模板化操作

## 文件格式

词库使用json格式存储

### 注释

由于json规范限制，**不支持文件内注释**。虽然bot理论上允许`json with comments`，不过保险起见，我建议使用`comment`来进行注释，如下：

```json
{
  "format_version": 1,
  "comment": "这是一行注释",
  "bank": [
    "......"
  ]
}
```

因此，如有其他插件要使用该词库，也请避免将`comment`用于实际功能，以免混淆

## 基本单位

词库实际的内容单元均在`bank`对应的数组中，每个对象均是一个响应单元。每个单元由响应器和回复组成

### 响应器格式

bot计划支持四种响应模式，分别是：

* 前缀匹配 (prefix)
* 关键词匹配 (keyword)
* 全字匹配 (full)
* 正则匹配 (regex)

每个单元只支持一种响应模式。各响应模式的具体参数如下：

* 前缀匹配：

```json
{
  "matcher": {
    "type": "prefix",
    "keyword": "你想要匹配的前缀"
  }
}
```

* 关键词匹配

```json
{
  "matcher": {
    "type": "keyword",
    "keyword": "你想要匹配的关键词",
    "simple_mode": false
  }
}
```

其中`simple_mode`是可选参数，默认值是`false`。当值为真时，将不使用`jieba`分词，而是直接在消息中暴力查找关键字

* 全字匹配

```json
{
  "matcher": {
    "type": "full",
    "text": "要匹配的文字"
  }
}
```

* 正则匹配

```json
{
  "matcher": {
    "type": "regex",
    "regex": "要使用的正则表达式",
    "ignore_case": true
  }
}
```
其中`ignore_case`是可选参数，默认为`true`，表示忽略大小写

另外，各响应器有三个公共参数：

1. `probability`，这表示该响应器生效的概率，按百分比计算。例如当该参数被设为25时，该响应器有75%的概率被跳过。未设置该参数时，按100计算
```plaintext
需要注意的是，当有多个响应器共同匹配同一文本时，各响应器的响应概率受先后顺序和优先级影响。
例如A概率为25%,B为100%,B在A后，则B实际响应概率为75%，因为只有A被跳过时，B才能截获该事件
```
2. `priority`，优先级，优先级高的将被优先匹配。未配置时，默认优先级为10。优先级高（数字更大）的将被优先匹配，同优先级的响应器，按在词库中出现的顺序进行匹配
3. `atme`，是否需要@bot来触发，未配置时默认为`true`


### 回复

bot计划支持六种回复格式以及一种回复限制。

为了支持多种回复，`reply`对应的值既可以是一个对象，也可以是包含多个对象的数组。

#### 回复格式

下面均假设每个响应单元仅有一个回复。

* 纯文本 (text)

```json
{
  "reply": {
    "type": "text",
    "text": "要使用的回复文本"
  }
}
```

* 图片 (image)

```json
{
  "reply": {
    "type": "image",
    "filename": "图片的文件名，需要在bot指定的资源目录中",
    "url": "图片的网络地址"
  }
}
```

需要注意的是，`filename`和`url`二选一提供即可。若二者均被提供，`url`将被**直接忽略**

* 语音 (voice)

```json
{
  "reply": {
    "type": "voice",
    "filename": "语音文件的文件名，同样需要在指定的资源目录中"
  }
}
```

* TTS (tts)

```json
{
  "reply": {
    "type": "tts",
    "text": "要转换成语音的文字",
    "lang": "对应的IETF语言标签"
  }
}
```

* 正则替换 (regex_sub)

```json
{
  "reply": {
    "type": "regex_sub",
    "pattern": "正则模式字符串",
    "repl": "用于替换的字符串，**只支持字符串**",
    "count": 0,
    "ignore_case": true
  }
}
```

其中`count`和`ignore_case`都是可选参数，前者表示最大替换个数（0表示无限），后者控制是否忽略大小写（默认忽略）

* 自定义代码 (code)

```json
{
  "reply": {
    "type": "code",
    "code": "要跑的代码（语言默认为python，否则消息传参会比较麻烦，如有更好方法还请提issue）",
    "local": false
  }
}
```

其中`local`是可选参数，表示是否在本地执行，默认为`false`（注意：公用词库应避免设定此值为`true`）

#### 回复限制

回复限制是指，在指定的限制条件下进行判断，若符合条件则返回允许(allow)，否则拒绝(deny)。

具体的限制及参数由bot开发者根据实际情况设定。`Flandre`目前将其和好感度系统集成，这是基于用户属性的判断。但限制能做的事不止于此。例如，你可以对`Flandre`
的聊天系统代码进行修改（在遵守AGPLv3协议的前提下），来添加日期，时间，乃至天气等等限制条件。

标准的回复限制格式如下：

```json
{
  "reply": {
    "type": "restricted",
    "restriction": {
      "type": "具体的限制方式",
      "xxx": "该限制方式所需要的参数"
    },
    "allow": {
      "reply": {
        "type": "some type",
        "xxx": "允许条件下的回复内容"
      }
    },
    "deny": {
      "reply": {
        "type": "some type",
        "xxx": "拒绝条件下回复内容"
      }
    }
  }
}
```

需要关注的有以下几点：

1. 虽然回复限制不属于回复类型，但它仍然应该被填在`reply`的`type`字段下。此举是为了简化判断
2. 具体的限制条件被写在`restriction`下。对开发者来说，只要各参数填写的值合法，则应当返回非黑即白的判断结果
3. `allow`和`deny`对应的值仍然是标准的回复，这意味着你仍然可以使用上述的五种回复格式来实现多元化的回复消息类型，可以填写附加选项，并且，如果bot开发者允许的话，限制条件可以套娃，来实现更复杂的限制
4. `allow`和`deny`都是可选参数。你既可以两个都提供，也可以只提供一个，甚至都不提供（不过这样毫无意义……）

##### 回复限制和Flandre的好感度系统集成

`Flandre`的好感度系统可以被用于设计回复限制，参考下面的用例：

```json
{
  "reply": {
    "type": "restricted",
    "restriction": {
      "type": "fav",
      "min_fav": 50
    },
    "allow": {
      "reply": {
        "type": "text",
        "text": "回复文本1"
      }
    },
    "deny": {
      "reply": {
        "type": "image",
        "filename": "回复图片.jpg"
      }
    }
  }
}
```

其中好感度的限制类型是`fav`，其唯一参数是`min_fav`，该参数控制被判定为”允许“的最低好感度应当是多少。在本例中，好感度大于等于50的用户将会得到文字回复，而低于50的用户会得到图片回复

#### 多回复
允许为同一触发条件设置不同的多个回复，此时各回复将被随机抽取。你也可以手动设置各回复的权重,权重更大的被抽取的概率更高。

使用方法很简单，在`reply`后提供一个包含多个回复的数组即可，如下：
```json
{
  "reply": [
    {
      "type": "text",
      "text": "文字回复",
      "weight": 1
    },
    {
      "type": "image",
      "filename": "图片回复.png",
      "weight": 2
    },
    {
      "type": "voice",
      "filename": "语音回复.mp3",
      "weight": 3
    }
  ]
}
```

### 附加功能

可以控制当触发器被激活后，会触发何种附加操作。这通常不是由对话系统来完成，而是由与对话系统关联的插件来接手。

附加功能的配置应当与`matcher`和`reply`同级，如下：

```json
{
  "matcher": {
    "......": ""
  },
  "reply": {
    "......": ""
  },
  "options": {
    "some options here": {
      "option 1": "value 1"
    }
  }
}
```
需要注意的是，各插件最好把自己的配置置于`options`下一个单独的对象中，而不是直接创建键值对，以免造成混乱

在与回复限制结合使用时，`options`**可以**与`allow`和`deny`中的`reply`同级，而不与`matcher`同级。这适用于在不同限制条件下，要触发不同附加操作的情况。当然，这应当也可以套娃（取决于bot开发者的实现）

一个大致的结构如下，假设允许条件要触发操作1，拒绝条件触发操作2，而两个条件下均要触发操作3：

```json
{
  "reply": {
    "type": "restricted",
    "restriction": {
      "type": "具体的限制方式",
      "xxx": "该限制方式所需要的参数"
    },
    "allow": {
      "reply": {
        "type": "some type",
        "xxx": "允许条件下的回复内容"
      },
      "options": {
        "some options here": "value 1"
      }
    },
    "deny": {
      "reply": {
        "type": "some type",
        "xxx": "拒绝条件下回复内容"
      },
      "options": {
        "some options here": "value 2"
      }
    }
  },
  "options": {
    "another option here": "value 3"
  }
}
```

#### 附加功能和Flandre好感度系统结合

目前，`Flandre`中使用了附加功能的也只有好感度。借此可以实现触发特定对话后，增减好感度的效果。其配置如下：

```json
{
  "reply": {
    "type": "text",
    "text": "回复文本"
  },
  "options": {
    "fav": {
      "type": "+",
      "num": 1,
      "max_daily": 3,
      "uuid": "55adcf89-7363-4ca7-aac0-0fd8247d0c50"
    }
  }
}
```
如上，好感度系统的附加功能配置位于`fav`中，有以下参数：
* `type`: 类型，有加("+")、减("-")、乘("*")、除("/")
* `num`: 数字，要加减乘除的数量（热知识：不要尝试除0，否则酒吧会炸>_<）
* `max_daily`: 该操作每天最大触发好感度变动的量，用于防止刷好感度，可选
* `uuid`: bot用于区分每个变动操作所使用的id，一般来说每个变动操作的id应当不同，但如有特殊需求，也可以设成相同的。该id并不一定要符合uuid规范，保证唯一性即可

### 其他语法
设定`[你]`用于指代发送者，`[我]`用于指代bot。对话系统在发送前，应当将上述文字替换为对应的称呼。注意**方括号是必需的**，这是有意为之，避免和句子中含义不同的“你”“我”造成混淆。

另外在`Flandre`中，`regex_sub`模式下，该语法并不会生效，其目的是防止发送者原句中的字词被错误替换
